- use oid to determine encryption algorithm
- implement packaging
- implement message ordering

Uitbreiding throttling:
Het automatisch versturen vanuit de ebms-adapter kan worden uitgezet, zodat een externe client dit proces kan overnemen.

Er wordt een nieuwe broker en client voor het versturen geimplementeerd.
De broker geeft een client pas een bericht als dit bericht ook daadwerkelijk verstuurd kan worden.
De client vraagt dus om een bericht bij de broker.
Zo wacht een client dus niet met een bericht versturen totdat dat mag, maar wacht een client op een bericht van de broker dat verstuurd mag worden.
Zo heb je geen concurrency problemen, heb je geen clients/channels per afnemer nodig en worden de clients optimaal gebruikt.
Als er 1 client uitvalt, loopt het berichtenverkeer ongehinderd door.
Als het te druk is, kun je gewoon het aantal clients opschalen.
Hierbij komt alle complexiteit in de broker te zitten en die kun je op verschillende manieren invullen en tunen.
De broker kan meervoudig worden uitgevoerd, maar er is altijd maar 1 actieve broker die berichten uitgeeft.
Het bepalen van de actieve broker kan in de clients worden ingebouwd, maar kan ook door containers worden gerealiseerd. Dit laatste heeft waarschijnlijk de voorkeur.
Misschien kan de broker als stored procedure op de database worden uitgevoerd, waarmee voorgaande probleem ook meteen is opgelost.
Het uitgangspunt is dat de client het bericht verstuurd op het moment dat deze het bericht aanneemt.
Retryen ten gevolge van een falende client gebeurt op basis van het ebms protocol.
Als de client een connectie error tegenkomt, dan kan deze het bericht zelf (of via de broker) weer in de event queue opslaan, zodat de broker het event later weer op kan pakken en vervolgens de url registreren bij de broker zodat deze de url tijdelijk kan negeren bij het uitgeven van berichten.

Een broker kan bijv als volgt worden geimplementeerd:
Een producer leest de berichten uit de event queue (en locked deze) en plaatst de berichten in channels per afnemer.
Een consumer leest de berichten uit de verschillende channels.
De channels leveren pas een bericht als dit mag worden verzonden.
De channels zijn ingedeeld in high en low priority channels, waarbij de high priority de throttled channels zijn (die weer gerangschikt zijn op basis van throttling timeout (van hoog naar laag)) en de low priority de overige.
De consumer bevraagt de channels op basis van priority (en begint eventueel opnieuw na een opgegeven tijd (waarbij in de low priority channels verder wordt gegaan waar de de vorige run is gestopt) of als alle channels zijn bevraagd).
De consumer bevraagt volgende channel pas als de volgende client zich aandient.

Er kunnen verschillende channels worden gerealiseerd dmv. verschillende broker.
Elke broker bedient een channel met 1 of meerdere afnemers.
Een afnemer wordt bedient vanuit 1 channel.

